// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: nowa.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Nowaproto_Restaurant {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique identifier for the restaurant.
  public var restaurantID: Int32 = 0

  /// Name of the restaurant.
  public var name: String = String()

  /// List of menu items belonging to this restaurant.
  public var menuItems: [Nowaproto_MenuItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Nowaproto_MenuItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique identifier for the menu item.
  public var itemID: Int64 = 0

  /// Status of the menu item.
  public var status: Nowaproto_MenuItem.Status = .unknown

  /// Name of the menu item.
  public var name: String = String()

  /// Description of the menu item.
  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case active // = 1
    case soldOut // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .active
      case 2: self = .soldOut
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .active: return 1
      case .soldOut: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Nowaproto_MenuItem.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Nowaproto_MenuItem.Status] = [
    .unknown,
    .active,
    .soldOut,
  ]
}

#endif  // swift(>=4.2)

public struct Nowaproto_Order {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique identifier for the order.
  public var orderID: Int64 = 0

  /// ID of the user who placed the order.
  public var userID: Int64 = 0

  /// ID of the restaurant that the order is for.
  public var restaurantID: Int32 = 0

  /// Status of the order.
  public var status: Nowaproto_Order.Status = .unknown

  /// List of items in this order.
  public var orderItem: [Nowaproto_Order.OrderItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case active // = 1
    case completed // = 2
    case cancelled // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .active
      case 2: self = .completed
      case 3: self = .cancelled
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .active: return 1
      case .completed: return 2
      case .cancelled: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct OrderItem {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Menu item.
    public var menuItem: Nowaproto_MenuItem {
      get {return _storage._menuItem ?? Nowaproto_MenuItem()}
      set {_uniqueStorage()._menuItem = newValue}
    }
    /// Returns true if `menuItem` has been explicitly set.
    public var hasMenuItem: Bool {return _storage._menuItem != nil}
    /// Clears the value of `menuItem`. Subsequent reads from it will return its default value.
    public mutating func clearMenuItem() {_uniqueStorage()._menuItem = nil}

    /// Quantity of the menu_item.
    public var quantity: Int32 {
      get {return _storage._quantity}
      set {_uniqueStorage()._quantity = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}
}

#if swift(>=4.2)

extension Nowaproto_Order.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Nowaproto_Order.Status] = [
    .unknown,
    .active,
    .completed,
    .cancelled,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "nowaproto"

extension Nowaproto_Restaurant: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Restaurant"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "restaurant_id"),
    2: .same(proto: "name"),
    3: .standard(proto: "menu_items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.restaurantID)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.menuItems)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.restaurantID != 0 {
      try visitor.visitSingularInt32Field(value: self.restaurantID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.menuItems.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.menuItems, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nowaproto_Restaurant, rhs: Nowaproto_Restaurant) -> Bool {
    if lhs.restaurantID != rhs.restaurantID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.menuItems != rhs.menuItems {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nowaproto_MenuItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MenuItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "item_id"),
    2: .same(proto: "status"),
    3: .same(proto: "name"),
    4: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.itemID)
      case 2: try decoder.decodeSingularEnumField(value: &self.status)
      case 3: try decoder.decodeSingularStringField(value: &self.name)
      case 4: try decoder.decodeSingularStringField(value: &self.description_p)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.itemID != 0 {
      try visitor.visitSingularInt64Field(value: self.itemID, fieldNumber: 1)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nowaproto_MenuItem, rhs: Nowaproto_MenuItem) -> Bool {
    if lhs.itemID != rhs.itemID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nowaproto_MenuItem.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "ACTIVE"),
    2: .same(proto: "SOLD_OUT"),
  ]
}

extension Nowaproto_Order: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Order"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_id"),
    2: .standard(proto: "user_id"),
    3: .standard(proto: "restaurant_id"),
    4: .same(proto: "status"),
    5: .standard(proto: "order_item"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.orderID)
      case 2: try decoder.decodeSingularInt64Field(value: &self.userID)
      case 3: try decoder.decodeSingularInt32Field(value: &self.restaurantID)
      case 4: try decoder.decodeSingularEnumField(value: &self.status)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.orderItem)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.orderID != 0 {
      try visitor.visitSingularInt64Field(value: self.orderID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.restaurantID != 0 {
      try visitor.visitSingularInt32Field(value: self.restaurantID, fieldNumber: 3)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 4)
    }
    if !self.orderItem.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orderItem, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nowaproto_Order, rhs: Nowaproto_Order) -> Bool {
    if lhs.orderID != rhs.orderID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.restaurantID != rhs.restaurantID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.orderItem != rhs.orderItem {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nowaproto_Order.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "ACTIVE"),
    2: .same(proto: "COMPLETED"),
    3: .same(proto: "CANCELLED"),
  ]
}

extension Nowaproto_Order.OrderItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Nowaproto_Order.protoMessageName + ".OrderItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "menu_item"),
    2: .same(proto: "quantity"),
  ]

  fileprivate class _StorageClass {
    var _menuItem: Nowaproto_MenuItem? = nil
    var _quantity: Int32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _menuItem = source._menuItem
      _quantity = source._quantity
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._menuItem)
        case 2: try decoder.decodeSingularInt32Field(value: &_storage._quantity)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._menuItem {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._quantity != 0 {
        try visitor.visitSingularInt32Field(value: _storage._quantity, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nowaproto_Order.OrderItem, rhs: Nowaproto_Order.OrderItem) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._menuItem != rhs_storage._menuItem {return false}
        if _storage._quantity != rhs_storage._quantity {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
